<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MergeSort Algorithm</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: 'Open Sans', sans-serif; margin: 0; }
        .text, .text-content { font-size: 18px; text-align: left; }
        .images { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
        .section { display: flex; flex-direction: column; align-items: center; max-width: 100%; margin-bottom: 20px; margin-left: 50px; margin-right: 50px; }
        .inline-image, .larger-image { display: block; margin: 5px auto; max-width: 400px; max-height: 400px; }
        .images img { max-width: 700px; max-height: 700px; }
        .questions, .options { display: flex; flex-direction: column; }
        .question, .options { margin-bottom: 10px; }
        .option { margin-bottom: 5px; }
        button { width: 150px; height: 40px; font-size: 18px; cursor: pointer; margin-top: 10px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <div id="content"></div>
    <button onclick="loadNextSection()">Continue</button>

    <script>
      let startTime = Date.now();
      let timer = setInterval(() => {
        const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        const timerElement = document.getElementById("timer");
        timerElement.textContent = `${minutes} minutes ${seconds} seconds elapsed`;
      }, 1000);



/*
       class TextSection {
        constructor(text, images = [], largerImage = null) {
          this.text = text;
          this.images = images;
          this.largerImage = largerImage;
        }

        render() {
          const div = document.createElement("div");
          div.classList.add("section", "text");

          const wrapper = document.createElement("div");
          wrapper.classList.add("text-image-wrapper");
          div.appendChild(wrapper);

          const textDiv = document.createElement("p");
          textDiv.innerHTML = this.text;
          textDiv.classList.add("text-content");
          wrapper.appendChild(textDiv);

          this.images.forEach(image => {
            const img = document.createElement("img");
            img.src = image;
            img.classList.add("inline-image");
            if (this.largerImage && image === this.largerImage) {
              img.classList.add("larger-image");
            }
            wrapper.appendChild(img);
          });

          return div;
        }
      }
*/
      class TextSection {
        constructor(text, images = [], largerImage = null) {
          this.text = text;
          this.images = images;
          this.largerImage = largerImage;
        }

        render() {
          const div = document.createElement("div");
          div.classList.add("section", "text");

          const textDiv = document.createElement("p");
          textDiv.innerHTML = this.text;
          textDiv.classList.add("text-content");
          div.appendChild(textDiv);

          const imagesDiv = document.createElement("div");
          imagesDiv.classList.add("images");
          div.appendChild(imagesDiv);

          this.images.forEach(image => {
            const img = document.createElement("img");
            img.src = image;
            img.classList.add("inline-image");
            imagesDiv.appendChild(img);
          });

          return div;
        }
      }



      class ImageSection {
          constructor(images, largerImage = null) {
              this.images = images;
              this.largerImage = largerImage;
          }

          render() {
              const div = document.createElement("div");
              div.classList.add("section", "images");

              this.images.forEach(image => {
                  const img = document.createElement("img");
                  img.src = image;
                  img.classList.add("inline-image");
                  if (this.largerImage && image === this.largerImage) {
                      img.classList.add("larger-image");
                  }
                  div.appendChild(img);
              });

              return div;
          }
      }


        class MultipleChoiceSection {
            constructor(question, options, correctIndex) {
                this.question = question;
                this.options = options;
                this.correctIndex = correctIndex;
            }

            render() {
                const div = document.createElement("div");
                div.classList.add("section", "questions");

                const questionDiv = document.createElement("div");
                questionDiv.classList.add("question");
                questionDiv.textContent = this.question;
                div.appendChild(questionDiv);

                const optionsDiv = document.createElement("div");
                optionsDiv.classList.add("options");
                this.options.forEach((option, index) => {
                    const optionLabel = document.createElement("label");
                    optionLabel.classList.add("option");

                    const optionInput = document.createElement("input");
                    optionInput.type = "radio";
                    optionInput.name = "option";
                    optionInput.value = index;

                    optionLabel.appendChild(optionInput);
                    optionLabel.appendChild(document.createTextNode(option));

                    optionsDiv.appendChild(optionLabel);
                });
                div.appendChild(optionsDiv);

                return div;
            }
        }

// ADD MORE MC QUESTIONS
// USE CODE STUFF
// AUDIENCE: BERKELEY GRAD STUDENT
// STATE EXPECTATIONS UP FRONT
// SOME CONTENT IS OLD - DON'T FOCUS ON THAT
// TIPS: THINK ABOUT PEDAGOGICAL SEQUENCING
// SECOND PART: LLM OR LANGUAGE BIAS - GOAL-ORIENTED ACTIVITIES


        const sections = [
            new TextSection(`Mig the Moonlit Menace has found treasure!
            A stack of eight chests,
            to be precise. But thereâ€™s a problem. The treasure chests all look the
            same. Mig wants to find out which chest is <b>heaviest</b>, so they
            know which has the most diamonds. <br><br>
            Luckily, Mig has a <b>scale</b> on his ship to compare two chests at a time.
            `, ["img/mig-pirate.png"]),

            new TextSection(`We've added the weights to the chests (don't tell Mig!)
            Can you sort them in ascending order?
            `, ["img/drag.png"]),

            new TextSection(`It seems so easy, but what you did is probably not
            as straightforward as it seems!<br>
            Maybe you started with the chest with the lowest number, and placed it
            at the left.
            Or maybe you started from the highest number, or swapped cards around
            using some other criteria.
            `),

            new TextSection(`
            If Mig were a naive pirate (which he isnt!), he could just compare
            all chests to one another. The number of permutations for a list of
            length n is n! (n factorial), which represents all possible orderings
            of the elements.
            `),

            new MultipleChoiceSection(`If he would have to use brute force to
              compare all 8 chests with
              one another, how many permutations would Mig have to make?`
              , ["24 permutations", "64 permutations", "40,320 permutations"], 1),


            new TextSection(`
            However, Mig doesn't have time to waste. There's more treasure out there!
            So Mig wants to try a more clever approach.
            One of these approaches is called <b>merge sort</b>, and it's pretty cool.
            Let's help Mig out.
            `),

            new TextSection(`
            Merge sort breaks the problem up in smaller parts.
            This is sometimes called a <strong>divide and conquer</strong> approach.
            Mig likes the sound of that!<br><br>

            For instance, let's say we'd split up our chests right down the middle,
            into two equal sub-stacks.<br>
            <ul>
            <li>We begin comparing the chests in both sub-stacks, starting on the left of both.</li>
            <li>The lightest chest of the two is moved back to the original stack.</li>
            <li>We then move to the next chest in the sub-stack we just removed a chest from.</li>
            </ul>
            Try it now!

            `),

            // change to chests
            new ImageSection(["img/layer1-1.png"]),
            new ImageSection(["img/layer1-2.png"]),
            new ImageSection(["img/layer1-3.png"]),

            new TextSection(`
            In merge sort,
            the act of comparing and putting the chests back is called <b>merging</b>.<br><br>
            We're getting closer to solving the problem.<br>
            However, it's not perfect. After all, we're not always comparing the
            right chests.
            But we don't have to stop here! We can keep splitting the chests
            until we can't go any further.<br><br>
            `),

            new ImageSection(["img/layerall-1.png"]),

            new TextSection(`
            Great job! We sorted, then merged the treasure chests based on their weights!
            "Merging" actually just means to put the chests back into a stack
            in the right order.
            `),
            new TextSection(`
            What we're doing has a fancy term: <b>recursion</b>.
            We basically split up the problem into smaller versions of itself.
            `),

            new TextSection(`
            Recursion happens a lot in programming.
            If we would code this, we could create a function that repeats itself
            when splitting and merging.<br><br>
            The code would first check the length of our input. If it's more than 1,
            it will find the midpoint, split the input in half, and <b>invoke itself</b>
            on each of the halves.
            `),

            new TextSection(`
            Try to put the following pseudo-code in order.
            Note that this is just the part of the code that splits up our list into sub-lists!
            `, ["img/Order.png"]),

            new TextSection(`
            Note the "call self" part of the code. This is called <b>recursion</b>.
            When we write this in code, we write a function that calls itself.
            `),

            new ImageSection(["img/Order2.png"]),
            new ImageSection(["img/Order3.png"]),
            new ImageSection(["img/Order4.png"]),
            new ImageSection(["img/Order5.png"]),


            new TextSection(`
            This is recursion in code! A function that calls itself in order to
            solve a smaller version of the same problem.
            `),

            new TextSection(`
            If we want to get a better intuition of what happens when we code this,
            we can <b>print out</b> the lists as they are created.
            `,["img/print.png"]),

            new MultipleChoiceSection("If we would print the left variable each time, what would the output be?", ["24 times", "48 times", "64 times"], 1),

            new TextSection(`
            Have a look at all the operations we did again.
            In total, we merge 8 + 8 + 8 = 24 times.<br><br>
            Recall that this is only slightly better than the 28 combinations
            we would need to do if we would just compare all chests.<br><br>
            However, if we start scaling this problem up, things start to look different.
            `),

            new ImageSection(["img/counter.png"]),

            new MultipleChoiceSection("How often would we merge if we had 16 chests?", ["24 times", "48 times", "64 times"], 1),

            new TextSection(`
            It turns out merge sort is a relatively efficient sorting algorithms.
            Let's see what happens if we make our collection of cards bigger!
            `),

            new ImageSection(["img/list_expansion1.png"]),
            new ImageSection(["img/list_expansion2.png"]),

            new TextSection(`
            Since we are splitting, the amount of steps we have to take increases
            based on the amount of items in the list.<br>
            We can express how much time an algorithm takes to solve a problem
            as a function of the size of the input. This is called
            <b>time complexity</b>.
            `),

            new TextSection(`
            In sorting algorithms, time complexity is often expressed in terms of
            "Big O" notation, which describes the worst-case scenario for the
            algorithm's runtime as the input size grows larger.<br><br>
            `),

            new TextSection(`
            In general, the time complexity of merge sort is O(n log n), which
            means that the time it takes to sort a list of size n grows
            logarithmically with n.<br><br>

            This process of dividing the list in half is logarithmic in nature,
            as each division reduces the number of elements by half!`
            ,["img/log.png"]),

            new TextSection(`Note that we're only assuming that n is always even
            to make things simple and to work with even sub-lists. However,
            merge sort also works with odd lengths of n.`,["img/scale.png"]),

            new TextSection(`Sorting algorithms come in all kinds of complexity.
            Here's a few!`,["img/graph.png"]),

            new TextSection(`
            In the next lesson you will learn about some ways to improve the
            efficiency of <b>merge sort</b>, which is still used in programming languages
            like Python every day!
            `),


        ];
        let currentSection = 0;

        function loadNextSection() {
            if (currentSection < sections.length) {
                const sectionElement = sections[currentSection].render();
                const previousSection = document.querySelector('.section:last-child');
                if (previousSection) {
                    previousSection.replaceWith(sectionElement);
                } else {
                    document.getElementById("content").appendChild(sectionElement);
                }
                currentSection++;
            } else {
                alert("No more sections to display.");
            }
        }

        // Load the first section when the page loads
        window.addEventListener("DOMContentLoaded", () => {
            loadNextSection();
        });
    </script>
    <div id="timer">0 seconds elapsed</div>

</body>
</html>
